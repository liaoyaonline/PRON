\chapter {关键技术}


\section {随机森林算法}
\subsection {随机森林算法介绍}
随机森林\cite{keyth:RF}\cite{keyth:EMiML}\cite{keyth:AECoTMfCEoDT}是通过决策树等弱分类器集成的强分类器，FernandezDelgado 等人通过大量实验在 121 个 UCI 数据集上比较了 179种分类算法的分类性能 , 实验结果表明 , 随机森林算法的分类性能是最优秀的 。\cite{keyth:DwNHoCtSRWCP}决策树是一种模仿人类if-then思考模式的分类算法，通过对分类对象若干特征取值的判断来划分对象类别的分类技术\cite{keyth:sjwjzcr}，决策树学习的目的就是为了产生一颗泛化能力强，即处理未见示例能力强的决策树，其基本流程遵循简单且直观的"分而治之"策略，如图\ref{fig:Tree}所示
\begin{figure}[H]
	\centering
	\includegraphics[width=12cm]{Figures/Tree.png}
	%\decoRule
	\caption{决策树 生成流程}
	\label{fig:Tree}
\end{figure}
随机森林算法是 Breiman 在 2001 年提出的,该算法属于组合分类方法的一
种 \cite{keyth:Alfsufsardfc}\cite{keyth:Sefbarfe}\cite{keyth:sjwjgny} 。随机森林中的每个个体分类器都是基于 CART 算法建立的决策树,因此随机森林算法可以解决分类和回归问题,每棵决策树的训练数据通过自助法
(bootstrap)也就是有放回的等概率随机抽样从原数据集中抽取,每个个体分类
器拥有各自不同的训练数据,所有个体分类器分类结果中的多数类或者平均值成
为随机森林的最终结果。随机森林生成流程图如图\ref{fig:RandomFroest}所示
\begin{figure}[H]
	\centering
	\includegraphics[width=12cm]{Figures/RandomFroest.png}
	%\decoRule
	\caption{RandomFroest 生成流程}
	\label{fig:RandomFroest}
\end{figure}

随机森林在生成过程中有以下特点:\newline
(1)单棵决策树的训练样本是通过从样本集中自助采样法得到，自助采样法进行有放回采样，对于包含m个样本的数据集D,生成的训练样本集为D',其步骤如下:\newline
1,每次随机从D中挑选一个样本，将其拷贝放入D',然后再将该样本放回初始数据集D中，使得该样本在下次采样时仍有可能被采到；\newline
2,重复m次，我们得到了包含m个样本的数据集D'.\newline
显然，D中有一部分样本会在D'中多次出现，而另一部分样本不出现。可以做个简单的估计，在m次采样中始终不被采到的概率为公式\ref{eqn:bootstrapping}
\begin{equation}
\lim_{m \to \infty}\left(1 - \frac{1}{m}\right)^m = \frac{1}{e} \approx 0.368
\label{eqn:bootstrapping}
\end{equation}
由公式\ref{eqn:bootstrapping}我们可知，训练样本集与总样本集的比值约为0.628，剩下的0.368可以在将来做为检测数据，所以随机森林在生成过程中就可以对模型的准确率进行估计，实验证明，这种估计属于无偏估计。\newline
(2)在决策树生成结点时，并不是从特征集所有特征中计算每个特征的基尼指数，然后选择最佳特征进行划分，而是从特征集中随机抽取K个特征，计算这K个特征的基尼指数，然后从里面选择最佳特征进行划分。在随机森林生成过程中，K的值是固定的。\newline
(3)随机森林中每棵决策树不进行剪枝处理，传统的决策树生成后会进行剪枝处理以避免过拟合，但随机森林本身两次随机策略（随机抽取训练样本集，结点分裂时选择随机K个分裂特征)能够很好的避免过拟合，不剪枝的另一个好处是消除了决策树的偏移。\newline
(4)随机森林的最终结果是由所有决策树投票表决得到的,每棵决策树拥有相同的投票权重,使用投票作为确定最终结果的策略使得随机森林算法的结果更加稳定。对于离散型的响应变量,使用多数表决的方法,选择所有结果中得票比例最高的作为随机森林分类的最终结果;对于连续型的响应变量,汇总所有决策树的结果,统计其平均值作为随机森林回归的最终结果。
\subsection {基于OOB误差的特征选择}
在处理多维数据时，如何从大量的特征中去除冗余或者无关的特征是提高预测模型泛化性能的关键。
随机森林的一个优点是，由于它的每个子树只使用了初始训练集中大约63.2\%的样本，剩下约36.8\%可以用来做验证集对该随机森林的泛化性能进行OOB误差估计(out-of-bag estimate),\cite{keyth:BP},该方法的优势就是可以直接获得模型的泛化误差,而不需要通过交叉验证或额外的计算来检验模型的优劣,且 OOB误差估计属于无偏估计\cite{keyth:CaRT} 。然后以OOB误差来对随机森林的特征集进行评估，从而剔除不相关特征和冗余特征。 \cite{keyth:MdwrfAsaront}。
基于 OOB 误差估计的变量选择,其基本原理是:在每次迭代的过程中,通
过预测变量$ X_{j}$的随机置换,该预测变量与响应变量Y的关联被打破\cite{keyth:Cvifrf} 。当被置换
后的预测变量$ X_{j}$连同其他未被置换的预测变量被用于预测袋外数据的响应变量
时,预测准确度会发生变化,若准确度发生较大幅度的下降,说明置换前的预测
变量$ X_{j}$与响应变量有关,该变量的重要性较大。\newline
因此,可以利用预测变量$ X_{j}$随机置换前后准确度变化的差值,所有决策树
平均后作为衡量变量重要性的度量,计算过程如下:
首先,计算预测变量 X j 在第 t 棵树中的重要性,计算见公式\ref{eqn:oob}:
\begin{equation}
VI^{(t)}(X_{j}) = \frac{\sum_{i \in B_{(t)}} I(y_i = y_{i}^{(t)})}{|B^{(t)}|} - \frac{\sum_{i \in B_{(t)}} I(y_i = y_{i,\pi_{j}}^{(t)})}{|B^{(t)}|}
\label{eqn:oob}
\end{equation}
公式\ref{eqn:oob}中，$ B{(t)}$是第 t 棵树的 OOB 数据,$ y_{i}^{(t)} = f^{(t)}{(x_i)}$是预测特征$ X_{j}$被替换前第i条记录的预测结果，$ y_{i,\pi_{j}}^{(t)} = f^{(t)}{(x_i,\pi_{j})}$是预测变量$ X_{j}$被替换后第i条记录的预测记过，由于节点的候选分裂属性是随机抽取的，因此会出现第t棵树中没有预测特征Xj的情况，此时定义$VI^{(t)} = 0$.\newline
变量 X j 的重要性计算结果是取所有树中该变量重要性的平均值,计算见公式\ref{eqn:avertree}
\begin{equation}
VI(X_{j}) = \frac{\sum^{n}_{t=1} VI^{(t)}(X_{j})}{n}
\label{eqn:avertree}
\end{equation}
最终选择变量数目最少且导致最小误差率的变量集合。
\subsection {小结}
随机森林采用集成算法，本身精度比大多数单个算法要好，准确率更高。并且由于样本的随机性以及特征的随机性，使其具有更好的泛化性能。随机森林属于非线性分类模型，所以它能处理非线性数据。且随机森林既能处理连续数据，又能处理离散数据。综上所述，本论文采用随机森林算法做为个性化推荐的核心算法。
\section {面向对象与UML建模}
\subsection {面向对象}
面向对象方法(Object-Oriented Method)是现在很成熟的一种软件开发方法,它借助于对象和类的概念对系统中的实体及其行为进行描述\cite{keyth:DoWATfSRRUWD}  。对象由多个属性和方法组成,在面向对象开发过程中,可以把所有的实体当作对象来看待。而类是对所有具有相同属性和方法的对象的总称或抽象。面向对象开发方法比传统的面向过程的方法更具有优势,具体表现在代码的安全和复用上。因为对象的方法是封装了一组代码的行为,对外部调用者而言,是不能看到对象内部的结构,除了那些可以被共享的公开信息。对于代码的复用问题,这在软件开发过程中也是很重要的一个问题。\newline
从对象的实现方式来看,由父类派生的子类所产生的对象会继承父类中的对象的特征,包括用于控制行为的操作代码\cite{keyth:mxdxcxs}。这本身就是一种很好的代码复用的情况。通常对于系统中的功能实现,会通过定义类的方法去完成。当面对具有相似功能的时候,无需定义新的类,而只需要创建这个类的实例就可以去完成这个功能。如果涉及到参数的变化,则可以通过创建这个类的子类去完成。而这里
面都包含了代码复用的过程,这对于维护系统的模块化和紧凑性是十分有用的。另外,面向对象开发还具有开发效率高,开发周期短的特点。而且也便于开展对系统进行功能扩充和维护工作。
\subsection {UML建模}
UML 是一种通用的、可视化的统一建模语言\cite{keyth:SAaDAOOAwU}  。对软件系统进行建模是一种必须要掌握的基本技能。尤其是在面向对象开发时代,一个好的建模过程可以大大降低系统的开发难度和复杂性。在传统的面向过程开发中,通常使用的是瀑布模型。而在面向对象开发中,主要使用 Rational 统一过程(RUP)方法。在RUP 方法使用过程中,有一个很重要的特征就是需要在软件的各个开发阶段建立合适的开发模型 \cite{keyth:jyUjmdj} 。由于软件的开发过程涉及到需求分析、系统设计、代码编写等诸多过程,因此,使用 RUP 方法都需要为其建立相应的模型。UML 在建模方面可以说是博采众长,它集中了许多建模工具的优点,把建模工作的可视化和文档化体现得淋漓尽致。一方面,可视化的建模效果可以帮助软件设计人员更好的把握系统的总体特征;另一方面,文档化也可以帮助软件开发人员便于阅读和保存建模结果,以便今后的重复利用\cite{keyth:Uzkhpxg} 。目前,把 RUP 和 UML 建模相结合的软件开发模式已经成为一种主流面向对象的开发方式。UML 建模的可视化主要体现在各种建模图形上 \cite{keyth:jyUdjxp} 。常用的 UML 建模图形包括用例图、活动图、类图、时序图、部署图和包图等。不同的图形被使用在不同的开发阶段中。例如,在系统需求分析时期,可以使用用例图和活动图来描述系统功能及其主要的业务活动流程 \cite{keyth:Ujmsjyf} 。在系统设计阶段,可以使用类图和时序图来描述软件系统的静态结构和动态模型。因为最终系统功能的实现需要借助软件的作用,而对软件结构建模可以提高软件的编写效率,降低软件开发的难度\cite{keyth:jyRdUjm} 。在系统实现阶段,部署图和包图具有很大的应用价值,因为系统整体组织结构上需要有软件和硬件的相互配合,而部署图和包图就可以体现出这种软硬件之间的逻辑关系\cite{keyth:TbAsaUcdawO} 。总之, UML建模可以很好的体现系统开发过程中所涉及的系统静态结构和动态特征。
\section {MySql数据库}
MySQL 把用户需要存储的数据放在不同的数据表中,并不是把所有数据一起
放在一个表中。这样做的好处就是提高了数据处理的速度和灵活性 \cite{keyth:jyRhGdr} 。
MySQL 也是采用的 SQL 语言,用于访问和处理数据库的标准的计算机语言。
MySQL 有两个版本分为社区版、商业版。同时也采用了双重授权策略。之所以很
多中小型企业选择 MySQL 作为他们首选的数据库,主要是因为:体积小、速度快、
成本低、开源等特点。
MySQL 通过 HandlerSocket 插件提供了 API 访问接口。HandlerSocket 提供
类似于 nosql 的网络服务,以守护进程插件的形式提供服务。它不会对数据进行
直接的处理,而是先侦听配置的端口,使用 NoSQL/API 接收通信协议,然后调用
存储引擎,通过 MySQL 中的处理程序 API 处理数据。
首先,它可以很好地满足数据的移植性能,可以在不同的平台中运行,代码
经过良好的测试,具有安全稳定的运行效率 \cite{keyth:dsjsdx}
其次,它具有较好的适应性。在不同的操作系统中可以很好地运行,可以支
持不同的用户语言的习惯,满足多语言的接口。可以在源代码中实现数据对象的
高效查询,满足极短时间范围内的数据对象的查询\cite{keyth:jqxxsfz}  。
综上所述,经过分析比较,MySql数据库与其他的数据库产品
和系统具有一定的特性和优势,可以满足用户的数据存储和管理的要求
\section {B/S架构}
B/S架构中,B 代表的是 Browser,即浏览器;S 代表的是 Server,即服务器 。B/S 架构,
其实是一种特殊的 C/S 架构,只不过这个 C(Client)特指浏览器。
对于 B/S 架构的系统,客户端计算机只需要安装常用的浏览器或者直接用系统自动安装的 IE 浏览器就可以访问服务端。浏览器只负责显示用户页面和提交请求,所有的逻辑业务都集中在服务器中处理。这样的优势在于系统升级维护时,只需要将服务器端的程序代码进行升级即可,而不需要对客户端进行处理,如此极大地减轻了升级所需的工作量,降低了人工成本。因为这个架构是
基于浏览器的,软件研发主要关注后台的业务处理逻辑,通过三层架构可以将数
据与表现分离出来。前端是客户端,主要是用户的浏览器\cite{keyth:SDzJxtz}  。用户只需使用自
己设备中的浏览器进行访问,不用安装部署任何软件,后期的使用更没有升级维护软件的麻烦。中间是服务器端,是进行业务处理的。后台是数据库,详细的架构具体如图\ref{fig:BS}所示\cite{keyth:DbzSSsj}。
\begin{figure}[H]
	\centering
	\includegraphics[width=12cm]{Figures/BS.png}
	%\decoRule
	\caption{B/S架构图}
	\label{fig:BS}
\end{figure}
在上述的 B/S 架构中主要包括了三个部分,分别是客户端、服务器、数据库:\newline
(1)客户端:主要的工作是接收用户的数据信息。由用户端的浏览器工具来完成,显示系统所处理结果。用户端在浏览器中通过 HTTP 请求将数据发送给服务器端,对于符合要求的请求在服务器端进行处理,将结果显示在用户端中。\newline
(2)服务器端:主要是进行业务的逻辑处理,在三层架构中起到上下承启作用。\newline
(3)数据库:主要是进行中间业务的请求,对各类请求的响应和处理,并将处理结果的数据完成存储\cite{keyth:gxsjkzc}。\newline
综上所述,在本系统的开发中,主要工作是中间业务的处理和数据库设计,
充分利用三层架构的优势,建立业务与数据之间的连接。
